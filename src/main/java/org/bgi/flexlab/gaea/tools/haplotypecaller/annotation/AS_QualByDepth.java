package org.bgi.flexlab.gaea.tools.haplotypecaller.annotation;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

import org.bgi.flexlab.gaea.data.structure.reference.ChromosomeInformationShare;
import org.bgi.flexlab.gaea.tools.haplotypecaller.ReadLikelihoods;
import org.bgi.flexlab.gaea.tools.haplotypecaller.utils.ReducibleAnnotationData;
import org.bgi.flexlab.gaea.tools.jointcalling.util.AnnotationUtils;
import org.bgi.flexlab.gaea.tools.jointcalling.util.GvcfMathUtils;
import org.bgi.flexlab.gaea.util.GaeaVCFConstants;

import htsjdk.variant.variantcontext.Allele;
import htsjdk.variant.variantcontext.Genotype;
import htsjdk.variant.variantcontext.GenotypesContext;
import htsjdk.variant.variantcontext.VariantContext;
import htsjdk.variant.vcf.VCFInfoHeaderLine;

public class AS_QualByDepth extends InfoFieldAnnotation implements ReducibleAnnotation, AS_StandardAnnotation {

    @Override
    public List<String> getKeyNames() { return Arrays.asList(GaeaVCFConstants.AS_QUAL_BY_DEPTH_KEY); }

    @Override
    public String getRawKeyName() { return GaeaVCFConstants.AS_QUAL_KEY; }


    @Override
    public List<VCFInfoHeaderLine> getRawDescriptions() {
        //We only have the finalized key name here because the raw key is internal to GenotypeGVCFs and won't get output in any VCF
        return getDescriptions();
    }

    @Override
    public Map<String, Object> annotate(final ChromosomeInformationShare ref,
                                        final VariantContext vc,
                                        final ReadLikelihoods<Allele> likelihoods ) {
        return Collections.emptyMap();
    }

    /**
     * Note: There is no raw annotation for AS_QualByDepth and thus this method does nothing.
     *       We expect the "AS_QUAL" key to be generated by genotypeGVCFs during genotyping.
     *
     * @param ref the reference context for this annotation
     * @param vc the variant context to annotate
     * @param likelihoods likelihoods indexed by sample, allele, and read within sample
     * @return
     */
    @Override
    public Map<String, Object> annotateRawData(final ChromosomeInformationShare ref,
                                               final VariantContext vc,
                                               final ReadLikelihoods<Allele> likelihoods) {
        return Collections.emptyMap();
    }

    /**
     * Note there is no raw annotation data for AS_QualByDepth and thus data cannot be combined
     *
     * @param allelesList   The merged allele list across all variants being combined/merged
     * @param listOfRawData The raw data for all the variants being combined/merged
     * @return
     */
    @Override
    @SuppressWarnings({"unchecked", "rawtypes"})//FIXME generics here blow up
    public Map<String, Object> combineRawData(List<Allele> allelesList, List<ReducibleAnnotationData<?>>  listOfRawData) {
        return null;
    }


    /**
     * Uses the "AS_QUAL" key, which must be computed by the genotyping engine in GenotypeGVCFs, to
     * calculate the final AS_QD annotation on the read.
     *
     * @param vc -- contains the final set of alleles, possibly subset by GenotypeGVCFs
     * @param originalVC -- used to get all the alleles for all gVCFs
     * @return
     */
    @Override
    public Map<String, Object> finalizeRawData(VariantContext vc, VariantContext originalVC) {
        //we need to use the AS_QUAL value that was added to the VC by the GenotypingEngine
        if ( !vc.hasAttribute(GaeaVCFConstants.AS_QUAL_KEY) ) {
            return null;
        }

        final GenotypesContext genotypes = vc.getGenotypes();
        if ( genotypes == null || genotypes.isEmpty() ) {
            return null;
        }

        final List<Integer> standardDepth = getAlleleDepths(genotypes);
        if (standardDepth == null) { //all no-calls and homRefs
            return null;
        }

        //Parse the VC's allele-specific qual values
        List<Object> alleleQualObjList = vc.getAttributeAsList(GaeaVCFConstants.AS_QUAL_KEY);
        if (alleleQualObjList.size() != vc.getNAlleles() -1) {
            throw new IllegalStateException("Number of AS_QUAL values doesn't match the number of alternate alleles.");
        }
        List<Double> alleleQualList = new ArrayList<>();
        for (final Object obj : alleleQualObjList) {
            alleleQualList.add(Double.parseDouble(obj.toString()));
        }

        // Don't normalize indel length for AS_QD because it will only be called from GenotypeGVCFs, never UG
        List<Double> QDlist = new ArrayList<>();
        double refDepth = (double)standardDepth.get(0);
        for (int i = 0; i < alleleQualList.size(); i++) {
            double AS_QD = -10.0 * alleleQualList.get(i) / ((double)standardDepth.get(i+1) + refDepth); //+1 to skip the reference field of the AD, add ref counts to each to match biallelic case
            // Hack: see note in the fixTooHighQD method below
            AS_QD = QualByDepth.fixTooHighQD(AS_QD);
            QDlist.add(AS_QD);
        }

        final Map<String, Object> map = new HashMap<>();
        map.put(getKeyNames().get(0), AnnotationUtils.encodeValueList(QDlist, "%.2f"));
        return map;
    }

    private List<Integer> getAlleleDepths(final GenotypesContext genotypes) {
        int numAlleles = -1;
        for (final Genotype genotype : genotypes) {
            if (genotype.hasAD()) {
                numAlleles = genotype.getAD().length;
                break;
            }
        }
        if (numAlleles == -1) { //no genotypes have AD
            return null;
        }
        Integer[] alleleDepths = new Integer[numAlleles];
        for (int i = 0; i < alleleDepths.length; i++) {
            alleleDepths[i] = 0;
        }
        for (final Genotype genotype : genotypes) {
            // we care only about genotypes with variant alleles
            if ( !genotype.isHet() && !genotype.isHomVar() ) {
                continue;
            }

            // if we have the AD values for this sample, let's make sure that the variant depth is greater than 1!
            if ( genotype.hasAD() ) {
                final int[] AD = genotype.getAD();
                final int totalADdepth = (int) GvcfMathUtils.sum(AD);
                if ( totalADdepth - AD[0] > 1 ) {
                    for (int i = 0; i < AD.length; i++) {
                        alleleDepths[i] += AD[i];
                    }
                }
            }
        }
        return Arrays.asList(alleleDepths);
    }
}

